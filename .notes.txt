------ Node.js + Express + MongoDb docs tutorial ------
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/skeleton_website

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Express.js, or simply    Express   ,                -->  is   a back end web application framework   for building   RESTful APIs   with   Node.js  ,
                                                         released as free and open-source software under the MIT License.
                                                         It is designed for building   web applications   and   APIs

Node.js                                             -->  is a cross-platform, open-source   JavaScript runtime environment   that can run on Windows, Linux, Unix, macOS, and more
                                                         Node.js runs on the   V8 JavaScript engine  (Chrome browser engine), and executes JavaScript code outside a web browser.

MongoDb                                             --> is a source-available, cross-platform,   document-oriented database program  . Classified as a   NoSQL database   product,
                                                        MongoDB uses JSON-like documents with optional schemas.              

   |->  Mongoose     -->   is a MongoDB object modeling tool (ORM/ODM - Object Relational Mapper/Object Document Mapper tool) designed to work in an asynchronous environment. 
                           Mongoose provides a straight-forward, schema-based solution to model your application data.
                           It includes built-in type casting, validation, query building, business logic hooks and more, out of the box.


---- Creating a skeleton website --------------------------------------------------------------------------------------------------------------------------------------------------------

npm install express-generator -g                    --> install the generator tool site-wide using the npm package manager

express express-locallibrary-tutorial --view=pug    --> command for generating project files using Express Application Generator, using the Pug template library and no CSS engine

The generator will create (and list) the project's files.

 create : express-locallibrary-tutorial\
   create : express-locallibrary-tutorial\public\
   create : express-locallibrary-tutorial\public\javascripts\
   create : express-locallibrary-tutorial\public\images\
   create : express-locallibrary-tutorial\public\stylesheets\
   create : express-locallibrary-tutorial\public\stylesheets\style.css
   create : express-locallibrary-tutorial\routes\
   create : express-locallibrary-tutorial\routes\index.js
   create : express-locallibrary-tutorial\routes\users.js
   create : express-locallibrary-tutorial\views\
   create : express-locallibrary-tutorial\views\error.pug
   create : express-locallibrary-tutorial\views\index.pug
   create : express-locallibrary-tutorial\views\layout.pug
   create : express-locallibrary-tutorial\app.js
   create : express-locallibrary-tutorial\package.json
   create : express-locallibrary-tutorial\bin\
   create : express-locallibrary-tutorial\bin\www

   change directory:
     > cd express-locallibrary-tutorial

   install dependencies:
     > npm install

   run the app (Bash (Linux or macOS))
     > DEBUG=express-locallibrary-tutorial:* npm start

   run the app (PowerShell (Windows))
     > $env:DEBUG = "express-locallibrary-tutorial:*"; npm start

   run the app (Command Prompt (Windows)):
     > SET DEBUG=express-locallibrary-tutorial:* & npm start

At the end of the output, the generator provides instructions on how to install the dependencies
(as listed in the package.json file) and how to run the application on different operating systems.

Note: The generator-created files define all variables as var. Open all of the generated files and change the var declarations to const before you continue
(the remainder of the tutorial assumes that you have done so).


---- Running the skeleton website

1. First, install the dependencies

cd express-locallibrary-tutorial    --> go to newly created directory

npm install     --> install all of the dependencies, the install command will   fetch   all the dependency   packages   listed in the project's   package.json   file

2. Then run the application.

Bash(macos/linux):
DEBUG=express-locallibrary-tutorial:* npm start     --> run the application with   debug mode
npm start --> run the application

On the Windows CMD prompt, use this command:
SET DEBUG=express-locallibrary-tutorial:* & npm start

On Windows PowerShell, use this command:
$env:DEBUG = "express-locallibrary-tutorial:*"; npm start

3. Then load http://localhost:3000/ in your browser to access the app.

Congratulations! You now have a working Express application that can be accessed via port 3000.


Note: You could also start the app just using the npm start command.
Specifying the DEBUG variable as shown enables console logging/debugging. For example, when you visit the above page you'll see debug output like this:

bash
SET DEBUG=express-locallibrary-tutorial:* & npm start

> express-locallibrary-tutorial@0.0.0 start D:\github\mdn\test\exprgen\express-locallibrary-tutorial
> node ./bin/www

  express-locallibrary-tutorial:server Listening on port 3000 +0ms
GET / 304 490.296 ms - -
GET /stylesheets/style.css 200 4.886 ms - 111


---- Enable server restart on file changes

Any changes you make to your Express website are currently not visible until you restart the server.

It quickly becomes very irritating to have to stop and restart your server every time you make a change,
so it is worth taking the time to automate restarting the server when needed.

A convenient tool for this purpose is nodemon. This is usually installed globally (as it is a "tool"),
but here we'll install and use it locally as a developer dependency, so that any developers working with the project get it automatically
when they install the application. Use the following command in the root directory for the skeleton project:

npm install --save-dev nodemon    --> Nodemon tool enables server restart on file changes, install as a developer dependency (and globaly: npm install -g nodemon)

If you still choose to install nodemon globally to your machine, and not only to your project's package.json file:

npm install -g nodemon

If you open your project's package.json file you'll now see a new section with this dependency:

json
{
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

Because the tool isn't installed globally, we can't launch it from the command line (unless we add it to the path).
However, we can call it from an npm script because npm knows which packages are installed. Find the scripts section of your package.json.
Initially, it will contain one line, which begins with "start". Update it by putting a comma at the end of that line, and adding the "devstart" and "serverstart" lines:

"scripts": {
    "start": "node ./bin/www",
    "devstart": "nodemon ./bin/www",
    "serverstart": "DEBUG=express-locallibrary-tutorial:* npm run devstart"
  },


On Windows, the "serverstart" value would instead look like this (if using the command prompt):

"serverstart": "SET DEBUG=express-locallibrary-tutorial:* & npm run devstart"


Now if you edit any file in the project the server will restart (or you can restart it by typing   rs   on the command prompt at any time).
You will still need to   reload the browser    to refresh the page.

We now have to call npm run <script-name> rather than just npm start, because "start" is actually an npm command that is mapped to the named script.
We could have replaced the command in the start script but we only want to use nodemon during development, so it makes sense to create a new script command.

The serverstart command added to the scripts in the package.json above is a very good example. Using this approach means you no longer have to type
a long command to start the server. Note that the particular command added to the script works for macOS or Linux only.


---- The generated project ---------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Directory structure

The generated project, now that you have installed dependencies, has the following file structure (files are the items   not   prefixed with "/").

The   package.json   file defines the application dependencies and other information.

It also defines a startup script that will call the application entry point, the JavaScript file   /bin/www.   

This sets up some of the application error handling and then loads   app.js   to do the rest of the work.

The app routes are stored in separate modules under the   routes/   directory. The templates are stored under the   /views   directory.


express-locallibrary-tutorial
    app.js
    /bin
        www
    package.json
    package-lock.json
    /node_modules
        [about 6700 subdirectories and files]
    /public
        /images
        /javascripts
        /stylesheets
            style.css
    /routes
        index.js
        users.js
    /views
        error.pug
        index.pug
        layout.pug


The following sections describe the files in a little more detail.


---- package.json

The   package.json   file defines the application dependencies and other information:


package.json:

{
  "name": "express-locallibrary-tutorial",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "http-errors": "~1.6.3",
    "morgan": "~1.9.1",
    "pug": "2.0.0-beta11"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

The scripts section first defines a "start" script, which is what we are invoking when we call npm start to start the server
(this script was added by the Express Application Generator).
From the script definition, you can see that this actually starts the JavaScript file   ./bin/www   with node.

We already modified this section in Enable server restart on file changes by adding the devstart and serverstart scripts.
 These can be used to start the same   ./bin/www   file with   nodemon    rather than node (this version of the scripts is for Linux and macOS, as discussed above).


The dependencies include the   express   package and the package for our selected   view engine (pug)  .
In addition, we have the following packages that are useful in many web applications:

cookie-parser: Used to parse the cookie header and populate req.cookies (essentially provides a convenient method for accessing cookie information).

debug: A tiny node debugging utility modeled after node core's debugging technique.

morgan: An HTTP request logger middleware for node.

http-errors: Create HTTP errors where needed (for express error handling).

-- How to update node project dependencies ? -----------------------------------

1. Update all dependencies to latest versions (non-breaking)

npm update

2. Upgrade to latest versions (including breaking changes)

To fully upgrade all packages (even if major versions change):


Option A: Use ncu (npm-check-updates)

npm install -g npm-check-updates    Install the tool (globally or as dev dep):

ncu                                 Check what needs updating

ncu -u                              Upgrade the versions in package.json

npm install                         Install the updated packages:

!! Major version upgrades can break things. Test thoroughly!


3. Check for outdated packages

npm outdated                        See what's out of date


This will show you:

Current version

Wanted version (according to semver range)

Latest version (even if it's a major version bump)


4. Test your project


After upgrading:

Run your test suite (npm test)

Check your app manually

Watch for deprecated APIs, breaking changes, or peer dependency issues


Bonus: Clean install - Sometimes it's good to start fresh

rm -rf node_modules package-lock.json
npm install

----------------------------------------------------------------------------------

!!!! run    npm install   after any changes in    package.json   !!!!

Note: It is a good idea to regularly update to the latest compatible versions of your dependency libraries
— this may even be done automatically or semi-automatically as part of a continuous integration setup.

Usually library updates to the minor and patch version remain compatible. 
We've prefixed each version with   ^   above so that we can automatically update to the latest minor.patch version by running:

npm update --save

Major versions change the compatibility. 
For those updates we'll need to   manually   update the   package.json   and   code   that uses the library, and extensively   re-test the project  .



---- www file

The file    /bin/www   is the application entry point!
The very first thing this does is   require()   the "real" application entry point (   app.js,   in the project root)
that sets up and returns the    express()    application object.

  require()   is the   CommonJS way   to import JavaScript code, JSON, and other files into the current file.
Here we specify   app.js   module using a relative path and omit the optional (.js) file extension.

js

#!/usr/bin/env node

/**
 * Module dependencies.
 */

const app = require("../app");


Note: Node.js 14 and later support ES6   import   statements for importing JavaScript (ECMAScript) modules.
To use this feature you have to add   "type": "module"   to your Express   package.json   file,
all the modules in your application have to use   import   rather than   require(),   and for   relative imports   you must include the file extension
 (for more information see the Node documentation  https://nodejs.org/api/esm.html#introduction ).
While there are benefits to using import, this tutorial uses require() in order to match the Express documentation.


---- app.js

This file creates an   express   application object (named   app,   by convention), sets up the application with various settings and middleware,
and then exports the app from the module. The code below shows just the parts of the file that create and export the app object:

js

const express = require("express");

const app = express();
// …
module.exports = app;


Back in the   www   entry point file above, it is this   module.exports   object that is supplied to the caller when this file is imported.


Let's work through the   app.js   file in detail.
First, we import some useful node libraries into the file using   require(),
including   http-errors,   express,   morgan   and   cookie-parser   that we previously downloaded for our application using npm;
and   path,   which is a   core Node library   for parsing file and directory paths.

const createError = require("http-errors");
const express = require("express");
const path = require("path");
const cookieParser = require("cookie-parser");
const logger = require("morgan");

Then we   require()   modules from our routes directory.
These modules/files contain code for handling particular sets of related "routes" (URL paths).
When we extend the skeleton application, for example to list all books in the library, we will add a new file for dealing with book-related routes.

const indexRouter = require("./routes/index");
const usersRouter = require("./routes/users");

Next, we create the   app   object using our imported   express   module, and then use it to set up the view (template) engine.
There are two parts to setting up the engine. First, we set the   "views"   value to specify the folder where the templates will be stored
(in this case the subfolder /views). Then we set the   "view engine"   value to specify the template library (in this case "pug").

const app = express();

// view engine setup
app.set("views", path.join(__dirname, "views"));
app.set("view engine", "pug");

The next set of functions call   app.use()   to add the   middleware   libraries that we imported above into the request handling chain.
For example,   express.json()   and   express.urlencoded()   are needed to populate   req.body   with the form fields.
After these libraries we also use the   express.static   middleware, which makes   Express   serve all the static files in the   /public   directory in the project root.

app.use(logger("dev"));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use(express.static(path.join(__dirname, "public")));

Now that    all the other middleware is set up,    we add our (previously imported)   route-handling code   to the request handling chain.
The imported code will define particular routes for the different parts of the site:

app.use("/", indexRouter);
app.use("/users", usersRouter);

Note: The paths specified above ("/" and "/users") are treated as a prefix to routes defined in the imported files.
So for example, if the imported users module defines a route for /profile, you would access that route at /users/profile.

The    last middleware   in the file adds handler methods for errors and HTTP 404 responses.

// catch 404 and forward to error handler
app.use((req, res, next) => {
  next(createError(404));
});

// error handler
app.use((err, req, res, next) => {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get("env") === "development" ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render("error");
});

The Express application object (app) is now fully configured. The last step is to add it to the module exports (this is what allows it to be imported by   /bin/www  ).

module.exports = app;

---- Routes

The route file   /routes/users.js   is shown below (route files share a similar structure, so we don't need to also show index.js).
First, it loads the   express   module and uses it to get an   express.Router   object  .
Then it specifies a route on that object and lastly exports the router from the module (this is what allows the file to be imported into   app.js  ).


const express = require("express");

const router = express.Router();

/* GET users listing. */
router.get("/", (req, res, next) => {
  res.send("respond with a resource");
});

module.exports = router;


The route defines a callback that will be invoked whenever an   HTTP   GET   request with the correct pattern is detected.
The matching pattern is the route specified when the module is imported ("/users") plus whatever is defined in this file ("/").
In other words, this route will be used when a URL of   /users/   is received.

Note: Try this out by running the server with node and visiting the URL in your browser: http://localhost:3000/users/.
You should see a message: 'respond with a resource'.

One thing of interest above is that the callback function has the third argument   next  ,
and is hence   a middleware function   rather than a simple route callback.
While the code doesn't currently use the next argument, it may be useful in the future if you want to add multiple route handlers to the '/' route path.

---- Views (templates)

The views (templates) are stored in the   /views   directory (as specified in   app.js  ) and are given the file extension   .pug  .
The method   Response.render()   is used to render a specified template along with the values of named variables passed in an object,
and then send the result as a response. In the code below from /routes/index.js you can see how that route renders a response using
the template "index" passing the template variable "title".

/* GET home page. */
router.get("/", (req, res, next) => {
  res.render("index", { title: "Express" });
});

The corresponding template for the above route is given below (index.pug). We'll talk more about the syntax later.
All you need to know for now is that the title variable (with value 'Express') is inserted where specified in the template.

extends layout

block content
  h1= title
  p Welcome to #{title}


--- Using a Database ( with MongoDB / Mongoose ) -------------------------------------------------------------------------------------------------------------------------------------------

---- What databases can I use?

Express apps can use any database supported by Node (Express itself doesn't define any specific additional behavior/requirements for database management).
There are many popular options, including PostgreSQL, MySQL, Redis, SQLite, and MongoDB.

Database integration:
https://expressjs.com/en/guide/database-integration.html

---- What is the best way to interact with a database?

There are two common approaches for interacting with a database:

- Using the databases' native query language, such as SQL.
- Using an   Object Relational Mapper ("ORM")   or   Object Document Mapper ("ODM").
  --> These represent the website's data as JavaScript objects, which are then mapped to the underlying database.
  --> Some ORMs and ODMs are tied to a specific database, while others provide a database-agnostic backend.

The very best performance can be gained by using SQL, or whatever query language is supported by the database.
Object mappers are often slower because they use translation code to map between objects and the database format,
which may not use the most efficient database queries (this is particularly true if the mapper supports different database backends,
and must make greater compromises in terms of what database features are supported).

The benefit of using an ORM/ODM is that programmers can continue to think in terms of JavaScript objects rather than database semantics
— this is particularly true if you need to work with different databases (on either the same or different websites).
They also provide an obvious place to perform data validation.

Note: Using ODM/ORMs often results in lower costs for development and maintenance! Unless you're very familiar with the native query language
or performance is paramount, you should strongly consider using an ODM.


---- Mongoose ----

Mongoose --> ODM - Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.
https://www.npmjs.com/package/mongoose

Mongoose acts as a front end to   MongoDB,   an open source  NoSQL database   that uses   a document-oriented data model  .
A "collection" of "documents" in a MongoDB database is analogous to a "table" of "rows" in a relational database.
https://mongoosejs.com/docs/guide.html


The rest of this tutorial shows    how to   define and access   the Mongoose   schema and models   for the LocalLibrary website example.


--- Designing the LocalLibrary models  -->    UML class diagram

When designing your models it makes sense to have separate models for every "object" (a group of related information).
In this case some obvious candidates for these models are books, book instances, and authors.

You might also want to use models to represent selection-list options (e.g., like a drop-down list of choices),
rather than hard-coding the choices into the website itself — this is recommended when all the options aren't known up front or may change.
A good example is a genre (e.g., fantasy, science fiction, etc.).

Once we've decided on our models and fields, we need to think about the relationships between them.

-- models
With that in mind, the   UML association diagram   below shows the models we'll define in this case (as boxes).
As discussed above, we've created   models   for the book (the generic details of the book), book instance
(status of specific physical copies of the book available in the system), and author. We have also decided to have a model
for the genre so that values can be created dynamically. We've decided not to have a model for the BookInstance:status
— we will hard code the acceptable values because we don't expect these to change. Within each of the boxes,
you can see the model name, the field names and types, and also the methods and their return types.

-- relationships
The diagram also shows the   relationships   between the models  , including their   multiplicities  .

The multiplicities   are the   numbers   on the diagram showing the   ! numbers (maximum and minimum) of each model that may be present in the relationship. !

For example, the   connecting line   between the boxes shows that Book and a Genre   are related  .

The numbers   close to the Book model   show that a   Genre must have   zero or more   Books (as many as you like), while the numbers on the other end of
the line next to the Genre show that a book can have zero or more associated Genres.


Note: As discussed in our Mongoose primer below it is often better to have the field that defines the relationship between the documents/models in just one model
(you can still find the reverse relationship by searching for the associated _id in the other model). Below we have chosen to define the relationship
between Book/Genre and Book/Author in the Book schema, and the relationship between the Book/BookInstance in the BookInstance Schema.
This choice was somewhat arbitrary — we could equally well have had the field in the other schema.

Note: The next section provides a basic primer explaining how models are defined and used.
As you read it, consider how we will construct each of the models in the diagram above.

---- Database APIs are asynchronous

Database methods to create, find, update, or delete records are    asynchronous  .

What this means is that   the methods return immediately  , and the   code to   handle   the success or failure   of the method   runs at a later time  !!!
when the operation completes.

Other code can execute while the server is waiting for the database operation to complete, so the server can remain responsive to other requests.

JavaScript has a number of mechanisms for supporting asynchronous behavior.
Historically JavaScript relied heavily on passing   callback functions   to asynchronous methods to handle the success and error cases.
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing

In modern JavaScript callbacks have largely been replaced by   Promises  .
Promises are objects that are (immediately) returned by an asynchronous method that represent its future state.
When the operation completes, the promise object is "settled", and resolves an object that represents the result of the operation or an error.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

There are two main ways you can use promises to run code when a promise is settled, and we highly recommend that you read How to use promises
for a high level overview of both approaches. In this tutorial, we'll primarily be using   await   to wait on promise completion within an   async function  ,
because this leads to more readable and understandable asynchronous code.


The way this approach works is that you use the   async function   keyword to mark a function as asynchronous, !!!
and then inside that function apply   await   to any method that returns a promise. 

1. When the asynchronous function is executed its operation is paused at the first   await   method until the promise settles.

2. From the perspective of the surrounding code the asynchronous function then returns and the code after it is able to run. 

3. Later when the promise settles, the   await   method inside the asynchronous function returns with the result, or an error is thrown if the promise was rejected.

4. The code in the asynchronous function then executes until either another await is encountered, at which point it will pause again,
or until all the code in the function has been run.


You can see how this works in the example below. myFunction() is an asynchronous function that is called within a try...catch block.
When myFunction() is run, code execution is paused at methodThatReturnsPromise() until the promise resolves, at which point the code continues
to functionThatReturnsPromise() and waits again. The code in the catch block runs if an error is thrown in the asynchronous function,
and this will happen if the promise returned by either of the methods is rejected.

async function myFunction() {
  // …
  await someObject.methodThatReturnsPromise();
  // …
  await functionThatReturnsPromise();
  // …
}

try {
  // …
  myFunction();
  // …
} catch (e) {
  // error handling code
}

The asynchronous methods above are run in sequence.
If the methods don't depend on each other then you can run them in parallel and finish the whole operation more quickly.
This is done using the   Promise.all()   method, which takes an iterable of promises as input and returns a single   Promise  .
This returned promise fulfills when all of the input's promises fulfill, with an array of the fulfillment values.
It rejects when any of the input's promises rejects, with this first rejection reason.

The code below shows how this works. First, we have two functions that return promises.
We await on both of them to complete using the promise returned by Promise.all().
Once they both complete await returns and the results array is populated, the function then continues to the next await,
and waits until the promise returned by anotherFunctionThatReturnsPromise() is settled. You would call the myFunction() in a try...catch block to catch any errors.

async function myFunction() {
  // …
  const [resultFunction1, resultFunction2] = await Promise.all([
    functionThatReturnsPromise1(),
    functionThatReturnsPromise2(),
  ]);
  // …
  await anotherFunctionThatReturnsPromise(resultFunction1);
}


--- Mongoose primer ---------------------------------------------------------------------------------------------------------------------------------------------------

This section provides an overview of   how to connect Mongoose to a MongoDB database  ,    how to define a schema and a model   , and    how to make basic queries  .


-- Installing Mongoose and MongoDB

   npm install mongoose


-- Connecting to MongoDB (locally hosted database)

  Mongoose   requires a connection to a   MongoDB database  .
  You can require() and connect to a locally hosted database with   mongoose.connect()   as shown below
  (for the tutorial we'll instead connect to an internet-hosted database).


// Import the mongoose module
const mongoose = require("mongoose");

// Set `strictQuery: false` to globally opt into filtering by properties that aren't in the schema
// Included because it removes preparatory warnings for Mongoose 7.
// See: https://mongoosejs.com/docs/migrating_to_6.html#strictquery-is-removed-and-replaced-by-strict
mongoose.set("strictQuery", false);

// Define the database URL to connect to.
const mongoDB = "mongodb://127.0.0.1/my_database";

// Wait for database to connect, logging an error if there is a problem
main().catch((err) => console.log(err));
async function main() {
  await mongoose.connect(mongoDB);
}

Note: As discussed in the Database APIs are asynchronous section, here we await on the promise returned by the connect() method within an async function.
We use the promise catch() handler to handle any errors when trying to connect, but we might also have called main() within a try...catch block.

You can get the default   Connection   object with   mongoose.connection.
If you need to create additional connections you can use   mongoose.createConnection()  .
This takes the same form of database URI (with host, database, port, options, etc.) as   connect()   and returns a   Connection   object.
Note that   createConnection()   returns immediately; if you need to wait on the connection to be established you can call it with   asPromise()   to return a promise
(mongoose.createConnection(mongoDB).asPromise()).


-- Defining and creating models

Models are defined using the   Schema   interface.
The Schema allows you to   define the fields   stored in each document along with their validation requirements and default values

In addition, you can   define static and instance helper methods   to make it easier to work with your data types,
and also   virtual properties   that you can use like any other field, but which aren't actually stored in the database (we'll discuss a bit further below).

Schemas are then   "compiled" into models   using the   mongoose.model()   method.

Once you have    a model   you can   use it   to   find  , create  , update  , and   delete   objects   of the given type.

Note: Each model maps to a collection of documents in the MongoDB database.
The documents will contain the fields/schema types defined in the model Schema.


-- Defining schemas

The code fragment below shows how you might   define a simple schema  .
First you   require()   mongoose, then    use the Schema constructor   to create   a new schema instance  , defining the various fields inside it in the constructor's object parameter.

// Require Mongoose
const mongoose = require("mongoose");

// Define a schema
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});


-- Creating a model

  Models   are created from schemas using the   mongoose.model()   method:

  // Define schema
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

// Compile model from schema
const SomeModel = mongoose.model("SomeModel", SomeModelSchema);

The first argument is the singular name of the collection that will be created for your model (Mongoose will create the database collection for the model SomeModel above),
and the second argument is the schema you want to use in creating the model.

Once you've defined your model classes you can use them to create, update, or delete records, and run queries to get all records or particular subsets of records.


 -- Schema types (fields)

 A schema can have an arbitrary number of   fields   — each one represents a field in the documents stored in MongoDB.
 An example schema showing many of the common   field types   and how they are declared is shown below.

 const schema = new Schema({
  name: String,
  binary: Buffer,
  living: Boolean,
  updated: { type: Date, default: Date.now() },
  age: { type: Number, min: 18, max: 65, required: true },
  mixed: Schema.Types.Mixed,
  _someId: Schema.Types.ObjectId,
  array: [],
  ofString: [String], // You can also have an array of each of the other types too.
  nested: { stuff: { type: String, lowercase: true, trim: true } },
});

Most of the   SchemaTypes   (the descriptors after "type:" or after field names) are self-explanatory.
The exceptions are:
    ObjectId:    Represents specific instances of a model in the database. For example, a book might use this to represent its author object.
                 This will actually contain the    unique ID (_id)   for the specified object. We can use the populate() method to pull in the associated information when needed.
    Mixed:       An arbitrary schema type.
    []:          An array of items. You can perform JavaScript array operations on these models (push, pop, unshift, etc.).
                 The examples above show an array of objects without a specified type and an array of String objects, but you can have an array of any type of object.

The code also shows both ways of declaring a field:

- Field   name   and   type   as    a key-value pair    (i.e. as done with fields name, binary and living).

- Field   name   followed by   an object   defining the   type  , and   any other options   for the field.
  Options include things like:
   - default values.
   - built-in validators (e.g. max/min values) and custom validation functions.
   - Whether the field is required
   - Whether String fields should automatically be set to lowercase, uppercase, or trimmed (e.g. { type: String, lowercase: true, trim: true })

More on SchemaTypes:    https://mongoosejs.com/docs/schematypes.html      https://mongoosejs.com/docs/typescript.html    https://mongoosejs.com/docs/typescript/schemas.html

-- Validation

Mongoose provides built-in and custom validators, and synchronous and asynchronous validators.
It allows you to specify both the acceptable range of values and the error message for validation failure in all cases.

The built-in validators include:

- All SchemaTypes have the built-in   required   validator. This is used to specify whether the field must be supplied in order to save a document.
-   Numbers   have   min   and   max   validators.
-   Strings   have:
  - enum: specifies the set of allowed values for the field.
  - match: specifies a regular expression that the string must match.
  - maxLength and minLength for the string.

The example below (slightly modified from the Mongoose documents) shows how you can specify some of the validator types and error messages:

const breakfastSchema = new Schema({
  eggs: {
    type: Number,
    min: [6, "Too few eggs"],
    max: 12,
    required: [true, "Why no eggs?"],
  },
  drink: {
    type: String,
    enum: ["Coffee", "Tea", "Water"],
  },
});

-- Virtual properties
   Virtual properties    are document properties that you can   get   and   set   but that   do not get persisted to MongoDB.

   The   getters   are useful for formatting or combining fields, while   setters   are useful for de-composing a single value into multiple values for storage.
   The example in the documentation constructs (and deconstructs) a   full name   virtual property from a   first   and   last name   field,
   which is easier and cleaner than constructing a full name every time one is used in a template.

    We will use a virtual property in the library to define a unique URL for each model record using a path and the record's _id value.

-- Methods and query helpers
  A schema can also have   instance methods  ,   static methods  , and   query helpers  .
  
  The   instance   and   static   methods are similar, but with the obvious difference that

  an instance method   is associated with a particular record   and   has access to the current object  .
  
  Query helpers   allow you to   extend mongoose's chainable query builder API   
  (for example, allowing you to add a query "byName" in addition to the find(), findOne() and findById() methods).

-- Using models
  Once you've created   a schema   you can use it to create   models  .
  
  The   model   represents  -->  a collection of documents in the database   that you can search,
  
  while the    model's instances    represent  -->  individual documents   that you can save and retrieve.

  Creation, update, deletion and querying of records are   asynchronous operations   that return a   promise  .
  The examples below show just the use of the relevant methods and   await   (i.e. the essential code for using the methods).
  The surrounding   async   function and   try...catch   block to catch errors are omitted for clarity. !!!

-- Creating and modifying documents
To create a record you can define an instance of the model and then call   save()   on it.
The examples below assume   SomeModel   is a model (with a single field   name  ) that we have created from our schema.

--
// Define schema
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

// Compile model from schema
const SomeModel = mongoose.model("SomeModel", SomeModelSchema);


// Create an instance of model SomeModel
const awesome_instance = new SomeModel({ name: "awesome" });

// Save the new model instance asynchronously
await awesome_instance.save();


You can also use   create()   to define the model instance at the same time as you save it.
Below we create just one, but you can create multiple instances by passing in an array of objects.

await SomeModel.create({ name: "also_awesome" });
--

Every model has an associated connection (this will be the default connection when you use mongoose.model()).
You create a new connection and call   .model()   on it to create the documents on a different database.

You can access the fields in this new record using the dot syntax, and change the values.
You have to call   save()   or   update()   to store modified values back to the database.

// Access model field values using dot notation
console.log(awesome_instance.name); //should log 'also_awesome'

// Change record by modifying the fields, then calling save().
awesome_instance.name = "New cool name";
await awesome_instance.save();


-- Searching for records

You can search for records using query methods, specifying the query conditions as a JSON document.
The code fragment below shows how you might   find all athletes   in a database that   play tennis  ,   returning just the fields for athlete   name   and   age  .
Here we just specify one matching   field   (sport) but you can add more criteria, specify regular expression criteria, or remove the conditions altogether to return all athletes.

const Athlete = mongoose.model("Athlete", yourSchema);

// find all athletes who play tennis, returning the 'name' and 'age' fields
const tennisPlayers = await Athlete.find(
  { sport: "Tennis" },
  "name age",
).exec();

Query APIs  , such as   find()  , return a variable of type Query.
You can   use a query object   to build up a query in parts   before   executing it   with the   exec()  method.
  exec() executes the query and returns   a promise   that you can   await   on for the result.

Above we've defined the query conditions in the   find()   method. We can also do this using a   where()   function,
and we can    chain   all the parts of our query together using the dot operator (.) rather than adding them separately.
The code fragment below is the same as our query above, with an additional condition for the age.

Athlete.find()
  .where("sport")
  .equals("Tennis")
  .where("age")
  .gt(17)
  .lt(50) // Additional where query
  .limit(5)
  .sort({ age: -1 })
  .select("name age")
  .exec();

The   find()   method gets all matching records, but often you just want to get one match.
The following methods query for a single record:

- findById(): Finds the document with the specified id (every document has a unique id).

- findOne(): Finds a single document that matches the specified criteria.

- findByIdAndDelete(),   findByIdAndUpdate()  ,    findOneAndRemove()  ,   findOneAndUpdate()  :
  Finds a single document by id or criteria and either updates or removes it. These are useful convenience functions for updating and removing records.

There is also a   countDocuments()   method that you can   use to get the number of items that match conditions  .
This is useful if you want to   perform a count   without   actually fetching the records.

More on queries: https://mongoosejs.com/docs/queries.html


-- Working with related documents — population

You can create references from   one document/model instance to another   using the   ObjectId   schema field  ,
or from   one document to many   using an   array   of ObjectIds.
The field stores the id of the related model.
If you need the actual content of the associated document, you can use the   populate()   method in a query to replace the id with the actual data.

For example, the following schema defines authors and stories.
Each author can have multiple stories, which we represent as an array of ObjectId.
Each story can have a single author.
The ref property tells the schema which model can be assigned to this field.

const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const authorSchema = new Schema({
  name: String,
  stories: [{ type: Schema.Types.ObjectId, ref: "Story" }],
});

const storySchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: "Author" },
  title: String,
});

const Story = mongoose.model("Story", storySchema);
const Author = mongoose.model("Author", authorSchema);


We can save our references to the related document by assigning the   _id   value.
Below we create an author, then a story, and assign the author id to our story's author field.

const bob = new Author({ name: "Bob Smith" });

await bob.save();

// Bob now exists, so lets create a story
const story = new Story({
  title: "Bob goes sledding",
  author: bob._id, // assign the _id from our author Bob. This ID is created by default!
});

await story.save();


Our story document now has an author referenced by the author document's ID.
In order to get the author information in the story results we use   populate()  , as shown below.

Story.findOne({ title: "Bob goes sledding" })
  .populate("author") // Replace the author id with actual author information in results
  .exec();

Astute readers will have noted that we added an author to our story, but we didn't do anything to add our story to our author's stories array.
How then can we get all stories by a particular author?
One way would be to add our story to the stories array, but this would result in us having two places where the information relating authors and stories needs to be maintained.

A better way is to get the _id of our author, then use find() to search for this in the author field across all stories.

Story.find({ author: bob._id }).exec();

More on populate: https://mongoosejs.com/docs/populate.html


-- One schema/model per file
While you can create schemas and models using any file structure you like, we highly recommend defining each model schema in its own module (file),
then exporting the method to create the model. This is shown below:

// File: ./models/some-model.js

// Require Mongoose
const mongoose = require("mongoose");

// Define a schema
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

// Export function to create "SomeModel" model class
module.exports = mongoose.model("SomeModel", SomeModelSchema);

You can then require and use the model immediately in other files. Below we show how you might use it to get all instances of the model.

// Create a SomeModel model just by requiring the module
const SomeModel = require("../models/some-model");

// Use the SomeModel object (model) to find all SomeModel records
const modelInstances = await SomeModel.find().exec();

--- Setting up a MongoDB database with MongDB Atlas ---

MongoDB Atlas --> cloud-hosted sandbox database


1. How to: set up new db in MongDB Atlas:   https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/mongoose
2. Install Mongoose package -->  npm install mongoose
3. Connect to MongoDB
  Open /app.js (in the root of your project) and copy the following text below where you declare the Express application object (after the line const app = express();).
  Replace the database URL string ('insert_your_database_url_here') with the location URL representing your own database (i.e. using the information from MongoDB Atlas).

  // Set up mongoose connection
const mongoose = require("mongoose");
mongoose.set("strictQuery", false);
const mongoDB = "insert_your_database_url_here";

main().catch((err) => console.log(err));
async function main() {
  await mongoose.connect(mongoDB);
}

As discussed in the Mongoose primer above, this code creates the default connection to the database and reports any errors to the console.

Note that hard-coding database credentials in source code as shown above is not recommended. !!!
We do it here because it shows the core connection code, and because during development there is no significant risk that leaking these details will expose
or corrupt sensitive information. We'll show you how to do this more safely when deploying to production!

4. Create models on seperate modules.

-- Defining the LocalLibrary Schema
Define a separate module for each model, as discussed above.
Start by creating a folder for our models in the project root (/models) and then create separate files for each of the models

/express-locallibrary-tutorial  // the project root
  /models
    author.js
    book.js
    bookinstance.js
    genre.js

5. Populate db using populatedb.js
   Run command:    node populatedb "<your MongoDB url>"


------- Routes and controllers -------------------------------------------------------------------------------------------------------------------------------------------
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/routes

The diagram (README.md) !!! is provided as a reminder of the main flow of data and things that need to be implemented when handling an HTTP request/response


As we've already created the models, the main things we'll need to create are:

-   "Routes"   to   forward   the supported requests (  and   any information encoded in request URLs) to the appropriate   controller functions  .

-   Controller functions   to   get   the requested data from the models,  create  an HTML page displaying the data, and  return it  to the user to view in the browser.

-   Views    (templates)   used by the controllers to   render the data  .

Ultimately we might have pages to show lists and detail information for books, genres, authors and bookinstances, along with pages to create, update, and delete records

--- Routes primer

A route    is a section of Express code that associates an   HTTP verb   (GET, POST, PUT, DELETE, etc.),
a URL path/pattern  , and   a function   that is called to handle that pattern.

There are several ways to create routes. For this tutorial we're going to use the    express.Router middleware    
as it allows us to   group the route handlers for a particular part of a site together   and   access them using   a common route-prefix  .

-- Defining and using separate route modules
-- Route functions

Router functions are Express   middleware   , which means that    they must either complete (respond to) the request   or   call the next function in the chain.

-- HTTP verbs

The example routes above use the   Router.get()   method to respond to HTTP GET requests with a certain path.

The Router also provides route methods for all the other HTTP verbs, that are mostly used in exactly the same way:
post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), proppatch(),
unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), subscribe(), unsubscribe(), patch(), search(), and connect().


-- Route paths

The route paths define the endpoints at which requests can be made. The examples we've seen so far have just been strings,
and are used exactly as written: '/', '/about', '/book', '/any-random.path'.

Route paths can also be string patterns. String patterns use a form of regular expression syntax to define patterns of endpoints that will be matched.
The syntax is listed below (note that the hyphen (-) and the dot (.) are interpreted literally by string-based paths):

?   : The endpoint must have   0 or 1   of the   preceding character   (or group), e.g. a route path of '/ab?cd' will match endpoints acd or abcd.
+   : The endpoint must have   1 or more   of the   preceding character   (or group), e.g. a route path of '/ab+cd' will match endpoints abcd, abbcd, abbbcd, and so on.
*   : The endpoint may have   an arbitrary string   where the * character is placed. E.g. a route path of '/ab*cd' will match endpoints abcd, abXcd, abSOMErandomTEXTcd, and so on.
()  : Grouping match on a set of characters to perform another operation on, e.g. '/ab(cd)?e' will perform a ?-match on the group (cd) — it will match abe and abcde.

The route paths can also be JavaScript regular expressions.


-- Route parameters

Route parameters are named   URL segments   used to capture values at specific positions in the URL

The named segments   are prefixed with a colon   and then the name (E.g.,   /:your_parameter_name/  ).
The captured values are stored in the   req.params   object  using the parameter names as keys (E.g.,   req.params.your_parameter_name  ).

So for example, consider a URL encoded to contain information about users and books:         http://localhost:3000/users/34/books/8989.
We can extract this information as shown below, with the userId and bookId path parameters:

app.get("/users/:userId/books/:bookId", (req, res) => {
  // Access userId via: req.params.userId
  // Access bookId via: req.params.bookId
  res.send(req.params);
});

The names of route parameters must be made up of "word characters" (A-Z, a-z, 0-9, and _).

The URL   /book/create   will be matched by a route like   /book/:bookId   (because :bookId is a placeholder for   any   string, therefore create matches).
The   first route that matches an incoming URL   will be used, so if you want to process /book/create URLs specifically,
their route handler   must be defined   before   your   /book/:bookId  route.

Express docs on routing:    https://expressjs.com/en/starter/basic-routing.html   https://expressjs.com/en/guide/routing.html

-- Handling errors in the route functions

The route functions shown earlier all have arguments   req   and   res  , which represent the request and response, respectively.
Route functions are also called with a third argument   next  , which can be used   to pass errors   to the Express middleware chain.

-- Handling exceptions in route functions

-- Routes needed for the LocalLibrary

The URLs that we're ultimately going to need for our pages are listed below, where   object   is replaced by the name of each of our models 
(book, bookinstance, genre, author),   objects   is the plural of object, and   id   is the unique instance field (_id) that is given to each Mongoose model instance by default.

catalog/ — The home/index page.
catalog/<objects>/ — The list of all books, bookinstances, genres, or authors (e.g. /catalog/books/, /catalog/genres/, etc.)
catalog/<object>/<id> — The detail page for a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37).
catalog/<object>/create — The form to create a new book, bookinstance, genre, or author (e.g. /catalog/book/create).
catalog/<object>/<id>/update — The form to update a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/update).
catalog/<object>/<id>/delete — The form to delete a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/delete).

The first home page and list pages don't encode any additional information.
While the results returned will depend on the model type and the content in the database, the queries run to get the information will always be the same
(similarly the code run for object creation will always be similar).

By contrast the other URLs are used to act on a specific document/model instance—these encode the identity of the item in the URL (shown as <id> above).
We'll use path parameters to extract the encoded information and pass it to the route handler
(and in a later article we'll use this to dynamically determine what information to get from the database).
By encoding the information in our URL we only need one route for every resource of a particular type (e.g. one route to handle the display of every single book item).

xpress allows you to construct your URLs any way you like — you can encode information in the body of the URL as shown above or use URL GET parameters (e.g. /book/?id=6).
Whichever approach you use, the URLs should be kept clean, logical and readable

--- Create the route-handler callback functions

Start by creating a folder for our controllers in the project root (/controllers) and then create separate controller files/modules for handling each of the models:

/express-locallibrary-tutorial  //the project root
  /controllers
    authorController.js
    bookController.js
    bookinstanceController.js
    genreController.js

The controllers will use the express-async-handler module, so before we proceed, install it into the library using npm:

npm install express-async-handler

--
express-async-handler module --> defines a wrapper function that hides the try...catch block and the code to forward the error. 


without express-async-handler module:

exports.get("/about", async function (req, res, next) {
  try {
    const successfulResult = await About.find({}).exec();
    res.render("about_view", { title: "About", list: successfulResult });
  } catch (error) {
    return next(error);
  }
});

with:

// Import the module
const asyncHandler = require("express-async-handler");

exports.get(
  "/about",
  asyncHandler(async (req, res, next) => {
    const successfulResult = await About.find({}).exec();
    res.render("about_view", { title: "About", list: successfulResult });
  }),
);

-- Create the catalog route module

The skeleton already has a ./routes folder containing routes for the index and users. Create another route file — catalog.js — inside this folder, as shown.

/express-locallibrary-tutorial //the project root
  /routes
    index.js
    users.js
    catalog.js

-- Update the index route module

-- Update app.js

 We have added our catalog module at a path '/catalog'. This is prepended to all of the paths defined in the catalog module.
 So for example, to access a list of books, the URL will be: /catalog/books/.

 --- Templates -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Displaying_data

 --- Template primer
 https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Displaying_data/Template_primer

 A   template   is   a text file defining the structure or layout of an output file  , with   placeholders   used to represent where data will be inserted when the template is rendered
 (in Express, templates are referred to as   views  ).

- Express template choices
Express can be used with many different template rendering engines. In this tutorial we use   Pug   (formerly known as   Jade  ) for our templates.

--- Working with forms
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/forms

-- Form handling process
Form handling uses all of the same techniques that we learned for displaying information about our models: the route sends
our request to a controller function which performs any database actions required, including reading data from the models, then generates and returns an HTML page.
What makes things more complicated is that the server also needs to be able to process the data provided by the user, and redisplay the form with error information
if there are any problems.


--- A process flowchart for processing form requests ( --> README ! ).
    Starting with a request for a page containing a form (shown in green).


As shown in the diagram, the main things that form handling code needs to do are:

1. Display the default form the first time it is requested by the user.

   - The form may contain blank fields (e.g. if you're creating a new record), or it may be pre-populated with initial values
     (e.g. if you are changing a record, or have useful default initial values).
     Receive data submitted by the user, usually in an HTTP POST request.

2. Validate and sanitize the data.

3. If any data is invalid, re-display the form—this time with any user populated values and error messages for the problem fields.

4. If all data is valid, perform required actions (e.g. save the data in the database, send a notification email, return the result of a search, upload a file, etc.)

5. Once all actions are complete, redirect the user to another page.


Often form handling code is implemented using a GET route for the initial display of the form
and a POST route to the same path for handling validation and processing of form data. This is the approach that will be used in this tutorial.

Express itself doesn't provide any specific support for form handling operations, but it can use middleware to process POST and GET parameters
from the form, and to validate/sanitize their values.

--- Validation and sanitization

Before the data from a form is stored it must be   validated   and   sanitized  :

  Validation   checks that entered values are appropriate for each field (are in the right range, format, etc.)
               and that values have been supplied for all required fields.

  Sanitization    removes/replaces characters in the data that might potentially be used to send malicious content to the server.

For this tutorial, we'll be using the popular   express-validator   module  to perform both validation and sanitization of our form data.
https://express-validator.github.io/docs/#basic-guide

-- Create genre form
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/forms/Create_genre_form

Same pattern is used in all our post controllers: we run validators (with sanitizers), then check for errors and either re-render the form with error information or save the data.

The form defines a single required field of type "text" called "name". The default value of the field depends on whether the genre variable is defined.
If called from the GET route it will be empty as this is a new form. If called from a POST route it will contain the (invalid) value originally entered by the user.

--- Deploying to production
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/deployment

-- What is a production environment?
The production environment is the environment provided by the server computer where you will run your website for external consumption. The environment includes:

- Computer hardware on which the website runs.
- Operating system (e.g. Linux or Windows).
- Programming language runtime and framework libraries on top of which your website is written.
- Web server infrastructure, possibly including a web server, reverse proxy, load balancer, etc.
- Databases on which your website is dependent.

The server computer could be located on your premises and connected to the Internet by a fast link, but it is far more common to use a computer that is hosted "in the cloud".

This sort of remotely accessible computing/networking hardware is referred to as    Infrastructure as a Service (IaaS)   .

Other hosting providers support Express as part of a    Platform as a Service (PaaS)    offering.
When using this sort of hosting you don't need to worry about most of your production environment (servers, load balancers, etc.) 
When you're getting started, setting up your website on a PaaS system is much easier, so that is what we'll do in this tutorial.

-- Database configuration